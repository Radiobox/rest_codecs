// The web_responders package takes care of our custom vendor codecs for
// Radiobox, handling responses, and even providing helpers for parsing
// input parameters.
package web_responders

import (
	"errors"
	"fmt"
	"github.com/stretchr/objx"
	"reflect"
	"strings"
	"unicode"
)

// database/sql has nullable values which all have the same prefix.
const SqlNullablePrefix = "Null"

// A Constructor is a function that is used by this package to
// construct additional structure around data.  It is called once per
// value in the response, starting with the deepest element in the
// response's structure and ending with the top level element of the
// response.  For each call, the original element is passed as the
// first argument (for interface/type checking), and the response that
// has been generated for that element is passed as the second
// argument.
//
// The Constructor should return the proper output structure and any
// error encountered.  The response logic will not descend into the
// structure of the value returned by the Constructor, so your
// constructor should not rely on the ResponseElementConverter or
// ResponseConverter interfaces for data within the structure it
// returns.
//
// One example use of a Constructor: If your system is supposed to
// guarantee a certain structure for links, you can have your codec
// pass a constructor which checks (and fixes) all link structures in
// a response.
type Constructor func(orig, output interface{}) (interface{}, error)

// A Response is a type used for storing data about and generating a
// response.  The Output() method is used for retrieving the output
// structure generated by this package.
type Response struct {
	Data         interface{}
	Constructor  Constructor
	Options      objx.Map
	AppendDomain string
	Messages     MessageMap

	output interface{}
}

// Output generates and returns the proper output structure for
// Response.Data, based on struct tags, interface matching, and output
// from any Constructor attached to the Response.
//
// Values which implement LazyLoader will have their LazyLoad method
// run first, in order to load any values that haven't been loaded
// yet.  The options passed to LazyLoad will be Response.Options.
//
// You can convert data when necessary by implementing the
// ResponseConverter, ResponseElementConverter, and/or
// NilElementConverter interfaces.  See the documentation for those
// types for more details.
//
// Struct values will be converted to a map[string]interface{}.  Each
// exported field's key in the map is generated using the first of the
// following methods that does not result in an empty string:
// 1. The "response" tag for that field.
// 2. The "db" tag for that field, if it is not "-"
// 3. The lowercase field name.
//
// Unexported struct fields will be ignored.
//
// A value of "-" for the "response" tag of a field will result in
// that field being skipped.
func (response *Response) Output() interface{} {
	if response.output == nil {
		response.output = response.createOutput()
	}
	return response.output
}

func (response *Response) createOutput() interface{} {
	if err, ok := response.Data.(error); ok {
		return err.Error()
	}
	if _, ok := response.Data.(MessageMap); ok {
		return response.Data
	}

	return createResponse(response.Data, response.AppendDomain, response.Options, response.Constructor)
}

func createResponse(data interface{}, domain string, options objx.Map, constructor Constructor) interface{} {
	if lazyLoader, ok := data.(LazyLoader); ok {
		lazyLoader.LazyLoad(options)
	}

	responseData := data
	if converter, ok := data.(ResponseConverter); ok {
		responseData = converter.ResponseData()
	}

	switch source := responseData.(type) {
	case fmt.Stringer:
		responseData = source.String()
	case error:
		responseData = source.Error()
	}

	value := reflect.ValueOf(responseData)
	for value.Kind() == reflect.Ptr && !value.IsNil() {
		value = value.Elem()
	}

	switch value.Kind() {
	case reflect.Ptr:
		// At this point in the code, value is only a reflect.Ptr if
		// it is nil.
		responseData = nil
	case reflect.Struct:
		responseData = createStructResponse(value, domain, options, constructor)
	case reflect.Slice, reflect.Array:
		responseData = createSliceResponse(value, domain, options, constructor)
	case reflect.Map:
		responseData = createMapResponse(value, domain, options, constructor)
	}

	if constructor != nil {
		var err error
		responseData, err = constructor(data, responseData)
		if err != nil {
			return err.Error()
		}
	}
	return responseData
}

// createNullableDbResponse checks for "database/sql".Null* types, or
// anything with a similar structure, and pulls out the underlying
// value.  For example:
//
//     type NullInt struct {
//         Int int
//         Valid bool
//     }
//
// If Valid is false, this function will return nil; otherwise, it
// will return the value of the Int field.
func createNullableDbResponse(value reflect.Value) (interface{}, error) {
	typeName := value.Type().Name()
	if strings.HasPrefix(typeName, SqlNullablePrefix) {
		fieldName := typeName[len(SqlNullablePrefix):]
		val := value.FieldByName(fieldName)
		isNotNil := value.FieldByName("Valid")
		if val.IsValid() && isNotNil.IsValid() {
			// We've found a nullable type
			if isNotNil.Interface().(bool) {
				return val.Interface(), nil
			} else {
				return nil, nil
			}
		}
	}
	return nil, errors.New("No Nullable DB value found")
}

// createMapResponse is a helper for generating a response value from
// a value of type map.
func createMapResponse(value reflect.Value, domain string, options objx.Map, constructor Constructor) interface{} {
	response := make(objx.Map)
	for _, key := range value.MapKeys() {
		itemResponse := createResponseValue(value.MapIndex(key), domain, options, constructor)
		response.Set(key.Interface().(string), itemResponse)
	}
	return response
}

// createSliceResponse is a helper for generating a response value
// from a value of type slice.
func createSliceResponse(value reflect.Value, domain string, options objx.Map, constructor Constructor) interface{} {
	response := make([]interface{}, value.Len())
	for i := 0; i < value.Len(); i++ {
		element := value.Index(i)
		response[i] = createResponseValue(element, domain, options, constructor)
	}
	return response
}

// createStructResponse is a helper for generating a response value
// from a value of type struct.
func createStructResponse(value reflect.Value, domain string, options objx.Map, constructor Constructor) interface{} {
	// Support "database/sql".Null* types, and any other types
	// matching that structure
	if v, err := createNullableDbResponse(value); err == nil {
		return v
	}

	response := make(objx.Map)
	for i := 0; i < value.NumField(); i++ {
		fieldType := value.Type().Field(i)
		fieldValue := value.Field(i)

		if fieldType.Anonymous {
			embeddedResponse := createResponse(fieldValue.Interface(), domain, options, constructor).(objx.Map)
			for key, value := range embeddedResponse {
				// Don't overwrite values from the base struct
				if _, ok := response[key]; !ok {
					response[key] = value
				}
			}
		} else if unicode.IsUpper(rune(fieldType.Name[0])) {
			name := ResponseTag(fieldType)
			switch name {
			case "-":
				continue
			default:
				response[name] = createResponseValue(fieldValue, domain, options, constructor)
			}
		}
	}
	return response
}

// createResponseValue is a helper for generating responses from
// sub-elements of a response.
func createResponseValue(value reflect.Value, domain string, options objx.Map, constructor Constructor) interface{} {
	responseValue := value.Interface()
	if value.Kind() == reflect.Ptr && !value.Elem().IsValid() {
		if nilResponder, ok := responseValue.(NilElementConverter); ok {
			responseValue = nilResponder.NilElementData()
		}
	} else if converter, ok := responseValue.(ResponseElementConverter); ok {
		responseValue = converter.ResponseElementData(options)
	}
	return createResponse(responseValue, domain, options, constructor)
}
